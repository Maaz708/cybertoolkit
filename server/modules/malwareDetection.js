const express = require('express');
const router = express.Router();
const fs = require('fs').promises;
const crypto = require('crypto');
const path = require('path');

class MalwareDetector {
  constructor() {
    this.signatures = new Map();
    this.patterns = [];
    this.currentFile = null;
    this.loadSignatures();
  }

  async loadSignatures() {
    try {
      const signaturesData = await fs.readFile(path.join(__dirname, 'signatures.json'), 'utf8');
      const data = JSON.parse(signaturesData);

      // Load hash-based signatures
      data.signatures.forEach(sig => {
        this.signatures.set(sig.hash, {
          type: sig.type,
          description: sig.description,
          severity: sig.severity || 'high'
        });
      });

      // Load pattern-based signatures with improved error handling
      this.patterns = data.patterns.map(pattern => {
        try {
          return {
            regex: new RegExp(pattern.pattern, 'i'),
            type: pattern.type,
            description: pattern.description,
            severity: pattern.severity || 'medium'
          };
        } catch (error) {
          console.warn(`Invalid pattern skipped: ${pattern.type}`, error.message);
          return null;
        }
      }).filter(Boolean);

      console.log('Signatures loaded successfully');
      console.log(`Loaded ${this.signatures.size} hash signatures and ${this.patterns.length} patterns`);
    } catch (error) {
      console.error('Error loading signatures:', error);
      this.signatures = new Map();
      this.patterns = [];
    }
  }

  checkSignatures(hashes) {
    // Check MD5
    const md5Match = this.signatures.get(hashes.md5);
    if (md5Match) return { ...md5Match, algorithm: 'md5' };

    // Check SHA1
    const sha1Match = this.signatures.get(hashes.sha1);
    if (sha1Match) return { ...sha1Match, algorithm: 'sha1' };

    // Check SHA256
    const sha256Match = this.signatures.get(hashes.sha256);
    if (sha256Match) return { ...sha256Match, algorithm: 'sha256' };

    return null;
  }

  async scanFile(filePath) {
    try {
      this.currentFile = filePath;

      // Check if file exists
      try {
        await fs.access(filePath);
      } catch (error) {
        throw new Error(`File not accessible: ${error.message}`);
      }

      // Read file content
      const buffer = await fs.readFile(filePath);
      const fileSize = buffer.length;
      const mimeType = this.getMimeType(filePath);

      // Calculate file hashes
      const hashes = this.calculateHashes(buffer);

      // Check for known malware signatures
      const signatureMatch = this.checkSignatures(hashes);

      // Perform enhanced heuristic analysis
      const heuristicResults = this.performHeuristicAnalysis(buffer, mimeType);

      // Calculate entropy for suspicious content detection
      const entropy = this.calculateEntropy(buffer);

      // Perform deep file analysis
      const fileAnalysis = this.analyzeFileContent(buffer, mimeType);

      // Calculate comprehensive risk score
      const risk_score = this.calculateRiskScore(signatureMatch, heuristicResults, entropy, fileAnalysis, mimeType);

      // Identify all threats
      const threats = this.identifyThreats(signatureMatch, heuristicResults, fileAnalysis);

      return {
        filename: path.basename(filePath),
        size: fileSize,
        mime_type: mimeType,
        timestamp: new Date().toISOString(),
        hashes,
        signatureMatch,
        suspicious_patterns: heuristicResults,
        entropy,
        file_analysis: fileAnalysis,
        risk_score,
        threats,
        recommendation: this.generateRecommendation(risk_score, threats)
      };
    } catch (error) {
      throw new Error(`Malware scan failed: ${error.message}`);
    } finally {
      this.currentFile = null;
    }
  }

  analyzeFileContent(buffer, mimeType) {
    const analysis = {
      suspicious_features: [],
      metadata: {},
      structure_analysis: {}
    };

    try {
      // Analyze based on file type
      switch (mimeType) {
        case 'application/pdf':
          analysis.suspicious_features = this.analyzePDF(buffer);
          break;
        case 'application/x-msdownload':
          analysis.suspicious_features = this.analyzeExecutable(buffer);
          break;
        case 'application/zip':
          analysis.suspicious_features = this.analyzeArchive(buffer);
          break;
      }

      // Extract metadata
      analysis.metadata = this.extractMetadata(buffer, mimeType);

      return analysis;
    } catch (error) {
      console.warn('File analysis error:', error);
      return analysis;
    }
  }

  analyzePDF(buffer) {
    const suspicious = [];
    const content = buffer.toString('utf8');

    const pdfPatterns = {
      javascript: /\/JavaScript/i,
      action: /\/Action/i,
      launch: /\/Launch/i,
      embedfile: /\/EmbeddedFile/i,
      uri: /\/URI\s*\(/i,
      openaction: /\/OpenAction/i
    };

    Object.entries(pdfPatterns).forEach(([type, pattern]) => {
      if (pattern.test(content)) {
        suspicious.push({
          type: `suspicious_pdf_${type}`,
          description: `Potentially malicious PDF ${type} content`,
          severity: 'medium'
        });
      }
    });

    return suspicious;
  }

  analyzeExecutable(buffer) {
    const suspicious = [];

    // Check for common suspicious patterns in executables
    const patterns = {
      packedCode: /UPX|ASPack|PECompact/i,
      suspiciousAPIs: /CreateRemoteThread|VirtualAlloc|WriteProcessMemory/i,
      networkActivity: /WSAStartup|socket|connect|InternetOpen/i
    };

    const content = buffer.toString('utf8');
    Object.entries(patterns).forEach(([type, pattern]) => {
      if (pattern.test(content)) {
        suspicious.push({
          type: `suspicious_exe_${type}`,
          description: `Suspicious executable feature: ${type}`,
          severity: 'high'
        });
      }
    });

    return suspicious;
  }

  analyzeArchive(buffer) {
    const suspicious = [];

    // Check for suspicious characteristics in archives
    if (buffer.includes(Buffer.from('PK'))) {
      // Check for nested archives
      const nestedArchiveCount = (buffer.toString('utf8').match(/\.zip|\.rar|\.7z/gi) || []).length;
      if (nestedArchiveCount > 2) {
        suspicious.push({
          type: 'nested_archives',
          description: `Multiple nested archives detected (${nestedArchiveCount} levels)`,
          severity: 'medium'
        });
      }
    }

    return suspicious;
  }

  calculateRiskScore(signatureMatch, heuristicResults, entropy, fileAnalysis, mimeType) {
    let score = 0;

    // Signature match is highest risk
    if (signatureMatch) score += 100;

    // Add points for suspicious patterns
    score += heuristicResults.length * 15;

    // Entropy scoring
    if (entropy > 7.5) score += 25;
    else if (entropy > 6.5) score += 15;

    // File type specific scoring
    if (mimeType.includes('executable')) {
      score += 10;
      // Add points for suspicious executable features
      if (fileAnalysis.suspicious_features) {
        score += fileAnalysis.suspicious_features.length * 10;
      }
    }

    // PDF specific scoring
    if (mimeType.includes('pdf')) {
      const pdfSuspiciousCount = fileAnalysis.suspicious_features.length;
      score += pdfSuspiciousCount * 8;
    }

    // Archive specific scoring
    if (mimeType.includes('zip')) {
      const archiveSuspiciousCount = fileAnalysis.suspicious_features.length;
      score += archiveSuspiciousCount * 12;
    }

    return Math.min(score, 100);
  }

  generateRecommendation(riskScore, threats) {
    if (riskScore >= 80) {
      return {
        action: 'BLOCK',
        message: 'High-risk file detected. Recommended action: Block and quarantine.',
        details: 'File contains known malicious signatures or highly suspicious features.'
      };
    } else if (riskScore >= 50) {
      return {
        action: 'WARNING',
        message: 'Moderate risk detected. Recommended action: Review before use.',
        details: 'File contains suspicious features that require attention.'
      };
    } else {
      return {
        action: 'ALLOW',
        message: 'Low risk file.',
        details: 'No significant threats detected.'
      };
    }
  }

  calculateHashes(buffer) {
    return {
      md5: crypto.createHash('md5').update(buffer).digest('hex'),
      sha1: crypto.createHash('sha1').update(buffer).digest('hex'),
      sha256: crypto.createHash('sha256').update(buffer).digest('hex')
    };
  }

  getMimeType(filePath) {
    const extension = path.extname(filePath).toLowerCase();
    const mimeTypes = {
      '.pdf': 'application/pdf',
      '.zip': 'application/zip',
      '.txt': 'text/plain',
      '.exe': 'application/x-msdownload',
      '.dll': 'application/x-msdownload'
    };
    return mimeTypes[extension] || 'application/octet-stream';
  }

  calculateEntropy(buffer) {
    const frequencies = new Array(256).fill(0);
    buffer.forEach(byte => frequencies[byte]++);

    return frequencies.reduce((entropy, freq) => {
      if (freq === 0) return entropy;
      const probability = freq / buffer.length;
      return entropy - probability * Math.log2(probability);
    }, 0);
  }

  performHeuristicAnalysis(buffer, mimeType) {
    const suspicious_patterns = [];
    const content = buffer.toString('utf8');

    this.patterns.forEach(pattern => {
      if (pattern.regex.test(content)) {
        suspicious_patterns.push({
          type: pattern.type,
          description: pattern.description
        });
      }
    });

    return suspicious_patterns;
  }

  identifyThreats(signatureMatch, heuristicResults, fileAnalysis) {
    const threats = [];

    if (signatureMatch) {
      threats.push({
        type: 'signature_match',
        severity: 'high',
        details: signatureMatch
      });
    }

    heuristicResults.forEach(pattern => {
      threats.push({
        type: 'suspicious_pattern',
        severity: 'medium',
        details: pattern
      });
    });

    if (fileAnalysis.suspicious_features) {
      fileAnalysis.suspicious_features.forEach(feature => {
        threats.push({
          type: feature.type,
          severity: feature.severity,
          details: feature
        });
      });
    }

    return threats;
  }

  extractMetadata(buffer, mimeType) {
    const metadata = {
      fileSize: buffer.length,
      mimeType: mimeType,
      createdAt: new Date().toISOString()
    };

    try {
      switch (mimeType) {
        case 'application/pdf':
          metadata.pdfVersion = this.extractPDFVersion(buffer);
          break;
        case 'application/zip':
          metadata.compression = 'deflate';
          metadata.encrypted = this.isZipEncrypted(buffer);
          break;
        case 'application/x-msdownload':
          metadata.peHeader = this.extractPEHeader(buffer);
          break;
      }
    } catch (error) {
      console.warn('Metadata extraction error:', error);
    }

    return metadata;
  }

  extractPDFVersion(buffer) {
    const header = buffer.toString('utf8', 0, 8);
    const match = header.match(/%PDF-(\d+\.\d+)/);
    return match ? match[1] : 'unknown';
  }

  isZipEncrypted(buffer) {
    // Check for encryption bit in ZIP header
    if (buffer.length > 6) {
      const generalPurposeBit = buffer[6];
      return (generalPurposeBit & 0x01) === 0x01;
    }
    return false;
  }

  extractPEHeader(buffer) {
    const peHeader = {
      isDLL: false,
      isExecutable: false,
      architecture: 'unknown'
    };

    try {
      if (buffer.length > 0x40) {
        // Check MZ header
        if (buffer[0] === 0x4D && buffer[1] === 0x5A) {
          peHeader.isExecutable = true;
        }
      }
    } catch (error) {
      console.warn('PE header extraction error:', error);
    }

    return peHeader;
  }
}

const detector = new MalwareDetector();

router.post('/scan', async (req, res) => {
  try {
    if (!req.files || !req.files.file) {
      return res.status(400).json({
        status: 'error',
        message: 'No file uploaded'
      });
    }

    const uploadedFile = req.files.file;
    console.log('Processing file:', uploadedFile.name);

    const tempPath = path.join(__dirname, '../tmp', `scan_${Date.now()}_${uploadedFile.name}`);
    await uploadedFile.mv(tempPath);
    console.log('File saved to:', tempPath);

    const scanResults = await detector.scanFile(tempPath);
    console.log('Scan completed:', scanResults);

    // Clean up
    try {
      await fs.unlink(tempPath);
    } catch (err) {
      console.error('Error cleaning up temp file:', err);
    }

    res.json({
      status: 'success',
      data: scanResults
    });
  } catch (error) {
    console.error('Malware scan error:', error);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Failed to scan file'
    });
  }
});

module.exports = router;